<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WANDERERSâ„¢</title>
    <link rel="icon" type="image/x-icon" href="./imgs/wanderericon.png" />
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        background-color: #b3c8cf; /* Light mode background */
        transition: background-color 0.3s ease;
        color: #000000; /* Light mode text color */
      }
      body.dark-mode {
        background-color: #333; /* Dark mode background */
        color: #ffffff; /* Dark mode text color */
      }
      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      button {
        --button_radius: 0.75em;
        --button_color: #ffffff;
        --button_outline_color: #000000;
        position: absolute;
        top: 20px;
        left: 20px;
        font-size: 17px;
        font-weight: bold;
        border: none;
        border-radius: var(--button_radius);
        background: var(--button_outline_color);
        padding: 0;
        cursor: pointer;
        z-index: 10;
      }
      .button_top {
        display: block;
        box-sizing: border-box;
        border: 2px solid var(--button_outline_color);
        border-radius: var(--button_radius);
        padding: 0.75em 1.5em;
        background: var(--button_color);
        color: var(--button_outline_color);
        transform: translateY(-0.2em);
        transition: transform 0.1s ease;
      }
      button:hover .button_top {
        transform: translateY(-0.3em);
      }
      button:active .button_top {
        transform: translateY(0);
      }
      .toggle-switch {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 20;
      }
      .toggle-switch input {
        display: none;
      }
      .slider {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
        background-color: #ccc;
        border-radius: 24px;
        cursor: pointer;
      }
      .slider:before {
        content: "";
        position: absolute;
        top: 2px;
        left: 2px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: white;
        transition: transform 0.2s;
      }
      input:checked + .slider:before {
        transform: translateX(26px);
      }
      input:checked + .slider {
        background-color: #666;
      }

      .popup {
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.278);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .popup-content {
        background: white;
        padding: 20px;
        border-radius: 5px;
        width: 300px;
        text-align: center;
        font-family: Arial, Helvetica, sans-serif;
        font-weight: bold;
        color: black;
      }

      .close-btn {
        float: right;
        font-size: 28px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="popup" class="popup" style="display: none">
      <div class="popup-content">
        <span class="close-btn" onclick="closePopup()">&times;</span>
        <p id="popup-message"></p>
      </div>
    </div>
    <div class="toggle-switch">
      <input
        type="checkbox"
        id="dark-mode-toggle"
        onchange="toggleDarkMode()"
      />
      <label class="slider" for="dark-mode-toggle"></label>
    </div>
    <button id="addButton">
      <span class="button_top">Add a <u>wanderer!</u></span>
    </button>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"
      defer
    ></script>
    <script>
      window.wandererTimeoutStarted = false;

      let wanderers = [];
      let groundLevel = 600; // Adjust this value based on your preference
      let messages = [
        "hey",
        "what's up",
        "beautiful weather!",
        "life is good!",
        "Hello there!",
        "Feeling great today!",
      ];
      let touchMessages = [
        "HEY!",
        "NO TOUCH!",
        "OW",
        "GO AWAY",
        "OUCH",
        "Stop touching!",
        "Avoid contact!",
      ];
      let dragMessages = [
        "LET GO",
        "NOO",
        "IM SCARED",
        "AAAA",
        "THIS IS HOW IT ENDS",
        "RELEASE ME!",
        "LET ME GO!",
        "WHY ME",
      ];
      let panicMessages = [
        "RUN!",
        "OH NO THEY GOT HIM",
        "THEY GOT DAVE",
        "Hey! that's my friend!",
        "Hey, leave them alone!",
      ];
      let numWanderers = 2;
      let activeWanderer = null;
      let prevWindowWidth, prevWindowHeight;
      let canvasBackgroundColor = 255; // Light mode by default (white)

      function setup() {
        createCanvas(windowWidth, windowHeight);
        textSize(16);
        textAlign(CENTER, CENTER);
        for (let i = 0; i < numWanderers; i++) {
          spawnWanderer();
        }
        frameRate(60);
        button = select("#addButton");
        button.mousePressed(addWanderer);
        prevWindowWidth = windowWidth;
        prevWindowHeight = windowHeight;
      }

      function draw() {
        background(canvasBackgroundColor);
        fill(60); // Grey color for the ground
        rect(0, groundLevel, width, height - groundLevel); // Draw the ground
        for (let i = wanderers.length - 1; i >= 0; i--) {
          wanderers[i].update();
          if (wanderers[i].visible) {
            wanderers[i].show(); // Only show wanderers that are visible
          }
          // Display particles whether the wanderer is visible or not
          wanderers[i].particles.forEach((particle) => particle.show());
          // Remove the wanderer from array if marked for removal
          if (wanderers[i].toRemove) {
            wanderers.splice(i, 1);
          }
        }

        let isCursorOverWanderer = false;
        for (let i = wanderers.length - 1; i >= 0; i--) {
          let wanderer = wanderers[i];
          wanderer.update();
          if (wanderer.toRemove) {
            wanderers.splice(i, 1);
            continue;
          }

          wanderer.displayMessage();
          if (
            dist(mouseX, mouseY, wanderer.x, wanderer.y) <
            wanderer.diameter / 2
          ) {
            isCursorOverWanderer = true;
          }
        }
        cursor(isCursorOverWanderer ? "pointer" : "auto");
      }

      function toggleDarkMode() {
        document.body.classList.toggle("dark-mode");
        // Check if dark mode is active and change the background color accordingly
        canvasBackgroundColor = document.body.classList.contains("dark-mode")
          ? 30
          : 255; // Dark grey for dark mode or white for light mode
      }

      function windowResized() {
        let widthChange = windowWidth - prevWindowWidth;
        let heightChange = windowHeight - prevWindowHeight;
        wanderers.forEach((wanderer) => {
          wanderer.xVelocity += widthChange * 0.05;
          wanderer.yVelocity += heightChange * 0.05;
        });
        resizeCanvas(windowWidth, windowHeight);
        prevWindowWidth = windowWidth;
        prevWindowHeight = windowHeight;
      }

      function addWanderer() {
        if (wanderers.length >= 20) {
          // Assuming 20 is the max number of wanderers
          if (!window.wandererTimeoutStarted) {
            window.wandererTimeoutStarted = true;
            setTimeout(fadeOutRandomWanderers, 3000); // 5000 milliseconds = 5 seconds
          }
          const warnings = [
            "OH NO TOO MUCH ANXIOUS WANDERERS!",
            "YOU'RE STRESSING THEM OUT!",
            "THEY'RE GONNA EXPLODE!",
          ];
          document.getElementById("popup-message").textContent =
            warnings[Math.floor(Math.random() * warnings.length)];
          document.getElementById("popup").style.display = "flex";
        } else {
          // Reset the timeout flag and reduction flag if under the limit
          window.wandererTimeoutStarted = false;
          reductionTriggered = false; // Resetting the reduction trigger flag
          let newColor = color(
            random(100, 255),
            random(100, 255),
            random(100, 255)
          );
          let newWanderer = new Wanderer(
            button.position().x + button.width / 2,
            button.position().y + button.height,
            55,
            0.5,
            0.6,
            newColor
          );
          let angle = PI / 2.6; // Directly downward
          let speed = random(3, 34); // Higher speed for a dramatic launch effect
          newWanderer.xVelocity = cos(angle) * speed;
          newWanderer.yVelocity = sin(angle) * speed;
          wanderers.push(newWanderer);
        }
      }

      // function addWanderer() {
      //   if (wanderers.length >= 20) {
      //     // Assuming 20 is the max number of wanderers
      //     // Start a 5-second timeout if not already started
      //     if (!window.wandererTimeoutStarted) {
      //       window.wandererTimeoutStarted = true;
      //       setTimeout(fadeOutRandomWanderers, 3000); // 5000 milliseconds = 5 seconds
      //     }
      //     const warnings = [
      //       "OH NO TOO MUCH ANXIOUS WANDERERS!",
      //       "YOU'RE STRESSING THEM OUT!",
      //       "THEY'RE GONNA EXPLODE!",
      //     ];
      //     document.getElementById("popup-message").textContent =
      //       warnings[Math.floor(Math.random() * warnings.length)];
      //     document.getElementById("popup").style.display = "flex";
      //   } else {
      //     // Reset the timeout flag if under the limit
      //     window.wandererTimeoutStarted = false;
      //     let newColor = color(
      //       random(100, 255),
      //       random(100, 255),
      //       random(100, 255)
      //     );
      //     let newWanderer = new Wanderer(
      //       button.position().x + button.width / 2,
      //       button.position().y + button.height,
      //       55,
      //       0.5,
      //       0.6,
      //       newColor
      //     );
      //     let angle = PI / 2.6; // Directly downward
      //     let speed = random(3, 34); // Higher speed for a dramatic launch effect
      //     newWanderer.xVelocity = cos(angle) * speed;
      //     newWanderer.yVelocity = sin(angle) * speed;
      //     wanderers.push(newWanderer);
      //   }
      // }

      function closePopup() {
        document.getElementById("popup").style.display = "none";
      }

      function spawnWanderer() {
        let initialColor = color(
          random(100, 255),
          random(100, 255),
          random(100, 255)
        );
        let newWanderer = new Wanderer(
          random(width),
          random(height),
          55,
          0.5,
          0.6,
          initialColor
        );
        wanderers.push(newWanderer);
      }

      let reductionTriggered = false;

      function fadeOutRandomWanderers() {
        if (!reductionTriggered && wanderers.length > 2) {
          let toFadeOut = wanderers.length - 2;
          let fadedCount = 0;

          wanderers.forEach((wanderer, index) => {
            if (!wanderer.fadingOut && fadedCount < toFadeOut) {
              wanderer.fadingOut = true;
              wanderer.fadeCounter = 0;
              fadedCount++;
            }
          });

          reductionTriggered = true; // Prevent further reduction
        }
      }

      class Wanderer {
        constructor(x, y, diameter, gravity, bounce, initialColor) {
          this.x = x;
          this.y = y;
          this.diameter = diameter;
          this.gravity = gravity;
          this.bounce = bounce;
          this.xVelocity = 0;
          this.yVelocity = 0;
          this.offsetX = 0;
          this.offsetY = 0;
          this.initialColor = initialColor;
          this.color = color(initialColor); // Ensure this is a p5 Color object
          this.particles = [];
          this.isExploding = false;
          this.fadingOut = false;
          this.fadeCounter = 0;
          this.shakingDuration = 300; // Frames of shaking and turning red
          this.hasExploded = false; // Ensures explosion happens only once
          this.visible = true; // New property to control visibility
        }

        update() {
          // Handle fading out and shaking
          if (this.fadingOut) {
            this.fadeCounter++;
            if (this.fadeCounter <= this.shakingDuration) {
              // Continue to shake and turn red
              this.color = lerpColor(this.color, color(255, 0, 0), 0.1);
              this.x += random(-2, 2);
              this.y += random(-2, 2);
            } else if (
              !this.hasExploded &&
              this.fadeCounter > this.shakingDuration
            ) {
              // Make the wanderer invisible and remove from list before starting explosion
              this.visible = false; // Wanderer is not visible anymore
              if (!this.isExploding) {
                // Start explosion only once
                for (let i = 0; i < 50; i++) {
                  this.particles.push(new Particle(this.x, this.y));
                }
                this.isExploding = true;
                this.hasExploded = true;
              }
            }
          }

          // Update particles if any
          if (this.isExploding) {
            this.particles.forEach((particle, index) => {
              particle.update();
              if (particle.isDone()) {
                this.particles.splice(index, 1);
              }
            });

            // Check if all particles are done to mark wanderer for complete removal
            if (this.particles.length === 0 && this.hasExploded) {
              this.toRemove = true;
            }
          }

          if (this.dragging) {
            // Update position only if not fading out
            this.x = mouseX + this.offsetX + random(-5, 5);
            this.y = mouseY + this.offsetY + random(-5, 5);
            this.color = lerpColor(this.color, color(255, 0, 0), 0.02);
            this.holdTimer++;
            if (this.holdTimer >= 200) {
              this.toRemove = true;
            }
            if (this.messageTimer === 0 || !this.draggingMessage) {
              this.message = random(dragMessages);
              this.messageTimer = 30;
              this.draggingMessage = true;
            }
            this.causePanic();
          } else {
            this.draggingMessage = false;
            this.x += this.xVelocity;
            this.y += this.yVelocity;
            this.yVelocity += this.gravity;
            this.checkCollisions();
            this.boundaryCollision();
            if (this.isHighlighted) {
              this.color = lerpColor(this.color, this.initialColor, 0.5);
              this.isHighlighted = false;
            } else {
              this.color = lerpColor(this.color, this.initialColor, 0.05);
            }
            if (this.messageTimer > 0) {
              this.messageTimer--;
            } else if (random(1000) < 5) {
              this.message = messages[floor(random(messages.length))];
              this.messageTimer = 180;
            }
          }
        }

        startExplosion() {
          if (!this.isExploding) {
            for (let i = 0; i < 50; i++) {
              this.particles.push(new Particle(this.x, this.y));
            }
            this.isExploding = true;
            this.hasExploded = true;
          }
        }

        causePanic() {
          const panicDistance = 150; // Distance within which other wanderers will panic
          wanderers.forEach((other) => {
            if (
              other !== this &&
              dist(mouseX, mouseY, other.x, other.y) < panicDistance &&
              !other.dragging
            ) {
              let dx = other.x - mouseX;
              let dy = other.y - mouseY;
              let distance = dist(mouseX, mouseY, other.x, other.y);
              other.xVelocity = (dx / distance) * 4;
              other.yVelocity = (dy / distance) * 0;
              if (other.messageTimer === 0) {
                other.message = random(panicMessages);
                other.messageTimer = 60;
              }
            }
          });
        }

        checkCollisions() {
          // Only check collisions if the wanderer is visible
          if (this.visible) {
            wanderers.forEach((other) => {
              if (other !== this && other.visible) {
                // Check only with other visible wanderers
                let d = dist(this.x, this.y, other.x, other.y);
                let collisionDist = this.diameter / 2 + other.diameter / 2;
                if (d < collisionDist) {
                  let overlap = 0.5 * (collisionDist - d);
                  let dx = (this.x - other.x) / d;
                  let dy = (this.y - other.y) / d;
                  this.x += overlap * dx;
                  this.y += overlap * dy;
                  other.x -= overlap * dx;
                  other.y -= overlap * dy;

                  // Apply a simple elastic collision response
                  this.xVelocity += dx * 2;
                  this.yVelocity += dy * 2;
                  other.xVelocity -= dx * 2;
                  other.yVelocity -= dy * 2;

                  this.message = random(touchMessages);
                  this.messageTimer = 60;
                  other.message = random(touchMessages);
                  other.messageTimer = 60;

                  this.isHighlighted = true;
                  other.isHighlighted = true;
                }
              }
            });
          }
        }

        show() {
          // Show particles
          this.particles.forEach((particle) => {
            particle.show();
          });

          // Only draw the wanderer and its messages if it is visible and not exploding
          if (this.visible && !this.isExploding) {
            fill(
              this.isHighlighted
                ? lerpColor(this.color, color(255, 255, 255), 0.5)
                : this.color
            );
            noStroke();
            ellipse(this.x, this.y, this.diameter);

            if (this.messageTimer > 0) {
              fill(this.dragging ? color(255, 0, 0) : this.color);
              text(this.message, this.x, this.y - 50);
            }
          }
        }

        displayMessage() {
          if (this.messageTimer > 0 && this.visible) {
            fill(this.dragging ? color(255, 0, 0) : this.color);
            text(this.message, this.x, this.y - 50);
          }
        }

        pressed() {
          let d = dist(mouseX, mouseY, this.x, this.y);
          if (d < this.diameter / 2 && activeWanderer == null) {
            this.dragging = true;
            activeWanderer = this;
            this.offsetX = this.x - mouseX;
            this.offsetY = this.y - mouseY;
            this.xVelocity = 0;
            this.yVelocity = 0;
            this.message = random(dragMessages);
            this.messageTimer = 30;
          }
        }

        released() {
          this.dragging = false;
          this.draggingMessage = false;
          this.holdTimer = 0; // Reset hold timer when released
          activeWanderer = null;
          this.xVelocity = (mouseX - pmouseX) / 1;
          this.yVelocity = (mouseY - pmouseY) / 1;
        }

        boundaryCollision() {
          // Check horizontal boundaries
          if (
            this.x > width - this.diameter / 2 ||
            this.x < this.diameter / 2
          ) {
            this.xVelocity *= -this.bounce;
            this.x = constrain(
              this.x,
              this.diameter / 2,
              width - this.diameter / 2
            );
          }

          // Check vertical boundaries (ground level)
          if (this.y >= groundLevel - this.diameter / 2) {
            this.y = groundLevel - this.diameter / 2; // Correct the position to sit exactly on the ground
            this.yVelocity *= -this.bounce;
            if (Math.abs(this.yVelocity) < 1) {
              // Check if the bounce is very small
              this.yVelocity = 0; // Stop the vertical movement if it's negligible
            }
          } else if (this.y < this.diameter / 2) {
            this.yVelocity *= -this.bounce;
            this.y = this.diameter / 2;
          }
        }
      }

      class Particle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.xVelocity = random(-15, 55); // Increase the spread
          this.yVelocity = random(-15, 55);
          this.size = random(5, 15); // Larger initial size
          this.opacity = 255; // Full opacity to start
        }

        update() {
          this.x += this.xVelocity;
          this.y += this.yVelocity;
          this.size += 5; // Slower shrink rate
          this.opacity -= 0.4; // Slower fade rate
        }

        show() {
          noStroke();
          fill(250, 112, 112, this.opacity);
          ellipse(this.x, this.y, this.size);
        }

        isDone() {
          return this.opacity <= 0;
        }
      }

      function mousePressed() {
        wanderers.forEach((wanderer) => wanderer.pressed());
      }

      function mouseReleased() {
        if (activeWanderer) {
          activeWanderer.released();
        }
      }
    </script>
  </body>
</html>
