<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WANDERERSâ„¢</title>
    <link rel="icon" type="image/x-icon" href="./imgs/wanderericon.png" />
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        background-color: #b3c8cf; /* Light mode background */
        transition: background-color 0.3s ease;
        color: #000000; /* Light mode text color */
      }
      body.dark-mode {
        background-color: #333; /* Dark mode background */
        color: #ffffff; /* Dark mode text color */
      }
      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      button {
        --button_radius: 0.75em;
        --button_color: #ffffff;
        --button_outline_color: #000000;
        position: absolute;
        top: 20px;
        left: 20px;
        font-size: 17px;
        font-weight: bold;
        border: none;
        border-radius: var(--button_radius);
        background: var(--button_outline_color);
        padding: 0;
        cursor: pointer;
        z-index: 10;
      }
      .button_top {
        display: block;
        box-sizing: border-box;
        border: 2px solid var(--button_outline_color);
        border-radius: var(--button_radius);
        padding: 0.75em 1.5em;
        background: var(--button_color);
        color: var(--button_outline_color);
        transform: translateY(-0.2em);
        transition: transform 0.1s ease;
      }
      button:hover .button_top {
        transform: translateY(-0.3em);
      }
      button:active .button_top {
        transform: translateY(0);
      }
      .toggle-switch {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 20;
      }
      .toggle-switch input {
        display: none;
      }
      .slider {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
        background-color: #ccc;
        border-radius: 24px;
        cursor: pointer;
      }
      .slider:before {
        content: "";
        position: absolute;
        top: 2px;
        left: 2px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: white;
        transition: transform 0.2s;
      }
      input:checked + .slider:before {
        transform: translateX(26px);
      }
      input:checked + .slider {
        background-color: #666;
      }
    </style>
  </head>
  <body>
    <div class="toggle-switch">
      <input
        type="checkbox"
        id="dark-mode-toggle"
        onchange="toggleDarkMode()"
      />
      <label class="slider" for="dark-mode-toggle"></label>
    </div>
    <button id="addButton">
      <span class="button_top">Add a <u>wanderer!</u></span>
    </button>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"
      defer
    ></script>
    <script>
      let wanderers = [];
      let messages = [
        "hey",
        "what's up",
        "beautiful weather!",
        "life is good!",
        "Hello there!",
        "Feeling great today!",
      ];
      let touchMessages = [
        "HEY!",
        "NO TOUCH!",
        "OW",
        "GO AWAY",
        "OUCH",
        "Stop touching!",
        "Avoid contact!",
      ];
      let dragMessages = [
        "LET GO",
        "NOO",
        "IM SCARED",
        "AAAA",
        "THIS IS HOW IT ENDS",
        "RELEASE ME!",
        "LET ME GO!",
        "WHY ME",
      ];
      let panicMessages = [
        "RUN!",
        "OH NO THEY GOT HIM",
        "THEY GOT DAVE",
        "Hey! that's my friend!",
        "Hey, leave them alone!",
      ];
      let numWanderers = 5;
      let activeWanderer = null;
      let prevWindowWidth, prevWindowHeight;
      let canvasBackgroundColor = 255; // Light mode by default (white)

      function setup() {
        createCanvas(windowWidth, windowHeight);
        textSize(16);
        textAlign(CENTER, CENTER);
        for (let i = 0; i < numWanderers; i++) {
          spawnWanderer();
        }
        frameRate(60);
        button = select("#addButton");
        button.mousePressed(addWanderer);
        prevWindowWidth = windowWidth;
        prevWindowHeight = windowHeight;
      }

      function draw() {
        background(canvasBackgroundColor); // Use the variable for background color
        let isCursorOverWanderer = false;
        for (let i = wanderers.length - 1; i >= 0; i--) {
          let wanderer = wanderers[i];
          wanderer.update();
          if (wanderer.toRemove) {
            wanderers.splice(i, 1);
            continue;
          }
          wanderer.show();
          wanderer.displayMessage();
          if (
            dist(mouseX, mouseY, wanderer.x, wanderer.y) <
            wanderer.diameter / 2
          ) {
            isCursorOverWanderer = true;
          }
        }
        cursor(isCursorOverWanderer ? "pointer" : "auto");
      }

      function toggleDarkMode() {
        document.body.classList.toggle("dark-mode");
        // Check if dark mode is active and change the background color accordingly
        canvasBackgroundColor = document.body.classList.contains("dark-mode")
          ? 30
          : 255; // Dark grey for dark mode or white for light mode
      }

      function windowResized() {
        let widthChange = windowWidth - prevWindowWidth;
        let heightChange = windowHeight - prevWindowHeight;
        wanderers.forEach((wanderer) => {
          wanderer.xVelocity += widthChange * 0.05;
          wanderer.yVelocity += heightChange * 0.05;
        });
        resizeCanvas(windowWidth, windowHeight);
        prevWindowWidth = windowWidth;
        prevWindowHeight = windowHeight;
      }

      function addWanderer() {
        if (wanderers.length >= 10) {
          wanderers.splice(floor(random(wanderers.length)), 1);
        }
        let newColor = color(
          random(100, 255),
          random(100, 255),
          random(100, 255)
        );
        let newWanderer = new Wanderer(
          button.position().x + button.width / 2,
          button.position().y + button.height,
          40,
          0.5,
          0.6,
          newColor
        );
        let angle = PI / 2.4; // Directly downward
        let speed = random(6, 14); // Higher speed for a dramatic launch effect
        newWanderer.xVelocity = cos(angle) * speed;
        newWanderer.yVelocity = sin(angle) * speed;
        wanderers.push(newWanderer);
      }

      function spawnWanderer() {
        let initialColor = color(
          random(100, 255),
          random(100, 255),
          random(100, 255)
        );
        let newWanderer = new Wanderer(
          random(width),
          random(height),
          40,
          0.5,
          0.6,
          initialColor
        );
        wanderers.push(newWanderer);
      }

      class Wanderer {
        constructor(x, y, diameter, gravity, bounce, initialColor) {
          this.x = x;
          this.y = y;
          this.diameter = diameter;
          this.gravity = gravity;
          this.bounce = bounce;
          this.dragging = false;
          this.xVelocity = 0;
          this.yVelocity = 0;
          this.offsetX = 0;
          this.offsetY = 0;
          this.initialColor = initialColor;
          this.color = initialColor;
          this.message = "";
          this.messageTimer = 0;
          this.isHighlighted = false;
          this.isHovered = false; // Indicates if the mouse is over the wanderer
          this.holdTimer = 0; // Timer to track how long the wanderer has been held
          this.toRemove = false; // Flag to mark wanderer for removal
        }

        update() {
          if (this.dragging) {
            this.x = mouseX + this.offsetX + random(-5, 5);
            this.y = mouseY + this.offsetY + random(-5, 5);
            this.color = lerpColor(this.color, color(255, 0, 0), 0.02);
            this.holdTimer++;
            if (this.holdTimer >= 200) {
              // 10 seconds at 60 fps
              this.toRemove = true;
            }
            if (this.messageTimer === 0 || !this.draggingMessage) {
              this.message = random(dragMessages);
              this.messageTimer = 30;
              this.draggingMessage = true;
            }
            this.causePanic();
          } else {
            this.draggingMessage = false;
            this.x += this.xVelocity;
            this.y += this.yVelocity;
            this.yVelocity += this.gravity;
            this.checkCollisions();
            this.boundaryCollision();
            if (this.isHighlighted) {
              this.color = lerpColor(this.color, this.initialColor, 0.5);
              this.isHighlighted = false;
            } else {
              this.color = lerpColor(this.color, this.initialColor, 0.05);
            }
            if (this.messageTimer > 0) {
              this.messageTimer--;
            } else if (random(1000) < 5) {
              this.message = messages[floor(random(messages.length))];
              this.messageTimer = 180;
            }
          }
        }

        causePanic() {
          const panicDistance = 150; // Distance within which other wanderers will panic
          wanderers.forEach((other) => {
            if (
              other !== this &&
              dist(mouseX, mouseY, other.x, other.y) < panicDistance &&
              !other.dragging
            ) {
              let dx = other.x - mouseX;
              let dy = other.y - mouseY;
              let distance = dist(mouseX, mouseY, other.x, other.y);
              other.xVelocity = (dx / distance) * 4;
              other.yVelocity = (dy / distance) * 4;
              if (other.messageTimer === 0) {
                other.message = random(panicMessages);
                other.messageTimer = 60;
              }
            }
          });
        }

        checkCollisions() {
          wanderers.forEach((other) => {
            if (other !== this) {
              let d = dist(this.x, this.y, other.x, other.y);
              let collisionDist = this.diameter / 2 + other.diameter / 2;
              if (d < collisionDist) {
                let overlap = 0.5 * (collisionDist - d);
                let dx = (this.x - other.x) / d;
                let dy = (this.y - other.y) / d;
                this.x += overlap * dx;
                this.y += overlap * dy;
                other.x -= overlap * dx;
                other.y -= overlap * dy;

                this.xVelocity += dx * 2;
                this.yVelocity += dy * 10;
                other.xVelocity -= dx * 2;
                other.yVelocity -= dy * 10;

                this.message = random(touchMessages);
                this.messageTimer = 60;
                other.message = random(touchMessages);
                other.messageTimer = 60;

                this.isHighlighted = true;
                other.isHighlighted = true;
              }
            }
          });
        }

        show() {
          if (this.isHighlighted) {
            fill(lerpColor(this.color, color(255, 255, 255), 0.5));
          } else {
            fill(this.color);
          }
          noStroke();
          ellipse(this.x, this.y, this.diameter);
        }

        displayMessage() {
          if (this.messageTimer > 0) {
            fill(this.dragging ? color(255, 0, 0) : this.color);
            text(this.message, this.x, this.y - 50);
          }
        }

        pressed() {
          let d = dist(mouseX, mouseY, this.x, this.y);
          if (d < this.diameter / 2 && activeWanderer == null) {
            this.dragging = true;
            activeWanderer = this;
            this.offsetX = this.x - mouseX;
            this.offsetY = this.y - mouseY;
            this.xVelocity = 0;
            this.yVelocity = 0;
            this.message = random(dragMessages);
            this.messageTimer = 30;
          }
        }

        released() {
          this.dragging = false;
          this.draggingMessage = false;
          this.holdTimer = 0; // Reset hold timer when released
          activeWanderer = null;
          this.xVelocity = (mouseX - pmouseX) / 1;
          this.yVelocity = (mouseY - pmouseY) / 1;
        }

        boundaryCollision() {
          if (
            this.x > width - this.diameter / 2 ||
            this.x < this.diameter / 2
          ) {
            this.xVelocity *= -this.bounce;
            this.x = constrain(
              this.x,
              this.diameter / 2,
              width - this.diameter / 2
            );
          }
          if (
            this.y > height - this.diameter / 2 ||
            this.y < this.diameter / 2
          ) {
            this.yVelocity *= -this.bounce;
            this.y = constrain(
              this.y,
              this.diameter / 2,
              height - this.diameter / 2
            );
          }
        }
      }

      function mousePressed() {
        wanderers.forEach((wanderer) => wanderer.pressed());
      }

      function mouseReleased() {
        if (activeWanderer) {
          activeWanderer.released();
        }
      }
    </script>
  </body>
</html>
